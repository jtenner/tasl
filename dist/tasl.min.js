(function(a,b){'object'==typeof exports&&'object'==typeof module?module.exports=b(require('pegjs')):'function'==typeof define&&define.amd?define(['pegjs'],b):'object'==typeof exports?exports.tasl=b(require('pegjs')):a.tasl=b(a.pegjs)})(this,function(a){return function(a){function b(d){if(c[d])return c[d].exports;var e=c[d]={i:d,l:!1,exports:{}};return a[d].call(e.exports,e,e.exports,b),e.l=!0,e.exports}var c={};return b.m=a,b.c=c,b.d=function(a,c,d){b.o(a,c)||Object.defineProperty(a,c,{configurable:!1,enumerable:!0,get:d})},b.n=function(a){var c=a&&a.__esModule?function(){return a['default']}:function(){return a};return b.d(c,'a',c),c},b.o=function(a,b){return Object.prototype.hasOwnProperty.call(a,b)},b.p='',b(b.s=5)}([function(a){a.exports=(a)=>({Type:'Rule',Name:a,generate(a){return{value:` ${a}:${this.Name}`,toString(){return this.value+' _'}}}})},function(a){a.exports={type:'Current',generate(a,b,c){return{value:` ${a}:${c}`,toString(){return this.value+' _'}}}}},function(a){a.exports={Type:'Next',generate(a,b){return{value:` ${a}:${b}`,toString(){return this.value+' _'}}}}},function(a){a.exports=(a,b=!1)=>({Type:'Literal',Value:a,Insensitive:b,generate(a){return{value:` ${a}:"${this.Value.replace(/"/g,'\\"')}"${this.Insensitive?'i':''}`,toString(){return this.value+' _'}}}})},function(a,b,c){const d=c(13);a.exports=class{constructor(a,b){this.grammar=a,this.parser=d.generate(a),this.parser.handler=b}evaluate(a,...b){return this.evaluateStatements(this.parser.parse(a),...b)}evaluateStatements(a,...b){let c,d;for(let e of a)if([c,d]=e.evaluate(...b),'return'===c)return d;return d}async evaluateAsync(a,...b){return this.evaluateStatementsAsync(this.parser.parse(a),...b)}async evaluateStatementsAsync(a,...b){let c,d;for(let e of a)if([c,d]=await e.evaluate(...b),'return'===c)return d;return d}}},function(a,b,c){a.exports={Current:c(1),evaluateExpressions:c(6),evaluateExpressionsAsync:c(7),evaluateStatements:c(8),evaluateStatementsAsync:c(9),Expression:c(10),ExpressionList:c(11),Grammar:c(12),Identifier:c(15),IdentifierList:c(16),Integer:c(17),Interpreter:c(4),Literal:c(3),Next:c(2),Optional:c(18),Or:c(19),RequiredWhitespace:c(20),Rule:c(0),Statement:c(21),StatementList:c(22)}},function(a){a.exports=(a,...b)=>{let c;for(const d of a)c=d.evaluate(...b);return c}},function(a){a.exports=async(a,...b)=>{let c=null;for(const d of a)c=await d.evaluate(...b);return c}},function(a){a.exports=(a,...b)=>{let c,d;for(const e of a)if([c,d]=e.evaluate(...b),'return'===c)return[c,d];return[null,d]}},function(a){a.exports=async(a,...b)=>{let c,d;for(const e of a)if([c,d]=await e.evaluate(...b),'return'===c)return[c,d];return[null,d]}},function(a,b,c){a.exports=c(0)('Expression')},function(a,b,c){a.exports=c(0)('ExpressionList')},function(a,b,c){const d=c(0),e=c(2),f=c(1),g=c(3),h=c(4);a.exports=class{constructor(){this.counts={E:-1,S:-1,C:-1,L:-1},this.handler={E:{},S:{},C:{}},this.keywords=[],this.terminator=';',this.grammar=c(14)}setTerminator(a){return this.terminator=a,this}addBinaryExpression(a){return this.addRule({Alias:a.Alias,Tokens:[['left',a.Left||e],['operator',g(a.Operator)],['right',a.Right||f]],Type:'E',Handler:a.Handler})}addUnaryExpression(a){return this.addRule({Alias:a.Alias,Tokens:'right'===a.Type?[['expression',a.Expression||e],['operator',g(a.Operator)]]:[['operator',g(a.Operator)],['expression',a.Expression||f]],Type:'E',Handler:a.Handler})}addExpression(a){const{Alias:b,Tokens:c,Handler:d}=a;return this.addRule({Alias:b,Tokens:c,Type:'E',Handler:d})}addStatement(a){const{Alias:b,Tokens:c,Handler:d}=a;return this.addRule({Alias:b,Tokens:c,Type:'S',Handler:d})}addCustom(a){const{Alias:b,Tokens:c,Handler:d}=a;return this.addRule({Alias:b,Tokens:c,Type:'C',Handler:d})}addRule(a){const{Alias:b,Tokens:c,Type:d,Handler:e}=a;this.counts[d]+=1;const f=`${d}${this.counts[d]}`;this.handler[d][f]=e;const g=`${d}${this.counts[d]+1}`;return this.grammar+=`
${b?`${b} = ${f}
`:``}${f} = ${this.spliceTokens(c,g,f)} {
  return {
    alias: "${b}",
    nodeType: "${d}",
    type: "${f}",
    evaluate,
    props: { ${c.map((a)=>a[0]).join(', ')} },
    text: text(),
    location: location()
  };
} ${'S'===d||'E'===d?`/ ${g}`:``}
`,this}addList(a){this.counts.L+=1;const b=`L${this.counts.L}`,c=a.Terminator?`_ "${a.Terminator.replace(/"/g,'\\"')}" `:``;return this.grammar+=`
${b} = ${a.Rule}
${a.Alias} = first:${b} last:(${c} _ ${b})* ${a.Terminator?c+'?':''} {
  return [first, ...last.map(x => x[${a.Terminator?3:1}])];
}
`,this}spliceTokens(a,b,c){let d='';for(let e=0;e<a.length;e++){let[f,h]=a[e];d+=(h.constructor===String?g(h):h).generate(f,b,c).toString()}return d}reserve(...a){return this.keywords.push(...a),this}generate(){return this.grammar+=`

E${this.counts.E+1} = ExpressionExit
S${this.counts.S+1} = StatementExit

${this.keywords.length?`Keyword = (${this.keywords.map((a)=>`"${a.replace(/"/g,'\\"')}"`).join(' / ')})`:'Keyword = "1"'} 
Terminator = "${this.terminator}"
`,new h(this.grammar,this.handler)}}},function(b){b.exports=a},function(a){a.exports='{\r\n  const { handler } = this;\r\n\r\n  function evaluate(...context) {\r\n    return handler[this.nodeType][this.type](this.props, ...context);\r\n  }\r\n  handler.S.SExpressionStatement = function SExpressionStatement({ expressions }, ...context) {\r\n    let value;\r\n    for(const expression of expressions) {\r\n      value = expression.evaluate(...context);\r\n    }\r\n    return [null, value];\r\n  };\r\n  handler.E.EReturnValue = function EReturnValue({ value }) { return value; }\r\n}\r\n\r\nProgram = _ statements:StatementList _ {\r\n  return statements;\r\n}\r\n\r\nStatementList = first:Statement last:(_ Statement)* {\r\n  return [first, ...last.map(x => x[1])];\r\n}\r\nExpressionList = first:Expression last:(_ \',\' _ Expression)* {\r\n  return [first, ...last.map(x => x[3])];\r\n}\r\nIdentifier = !Keyword [a-zA-Z$_][a-zA-Z$_0-9]* {\r\n  return {\r\n    nodeType: \'I\',\r\n    type: \'Identifier\',\r\n    value: text(),\r\n    text: text(),\r\n    location: location()\r\n  };\r\n}\r\nIdentifierList = first:Identifier last:(_ "," _ Identifier)* {\r\n  return [first, ...last.map(x => x[3])];\r\n}\r\n\r\nStatement = S0\r\nExpression = E0\r\n\r\nExpressionExit = Float\r\n\r\nFloat = [0-9]+ "." [0-9]+ {\r\n  return {\r\n    nodeType: \'E\',\r\n    type: \'EReturnValue\',\r\n    evaluate,\r\n    props: {\r\n      value: parseFloat(text()),\r\n    },\r\n    text: text(),\r\n    location: location()\r\n  };\r\n} / Integer\r\n\r\nInteger = [0-9]+ {\r\n  return {\r\n    nodeType: \'E\',\r\n    type: \'EReturnValue\',\r\n    evaluate,\r\n    props: {\r\n      value: parseInt(text(), 10),\r\n    },\r\n    text: text(),\r\n    location: location()\r\n  };\r\n} / Null\r\n\r\nNull = "null" {\r\n  return {\r\n    nodeType: \'E\',\r\n    type: \'EReturnValue\',\r\n    evaluate,\r\n    props: {\r\n      value: null,\r\n    },\r\n    text: text(),\r\n    location: location()\r\n  };\r\n}\r\n\r\nStatementExit = ExpressionStatement\r\n\r\nExpressionStatement = expressions:ExpressionList _ Terminator? {\r\n  return {\r\n    alias: \'ExpressionStatement\',\r\n    nodeType: "S",\r\n    type: \'SExpressionStatement\',\r\n    evaluate,\r\n    props: { expressions },\r\n    text: text(),\r\n    location: location()\r\n  };\r\n}\r\n\r\n_ = [\\t\\r\\n ]*\r\n__ = [\\t\\r\\n ]+'},function(a,b,c){a.exports=c(0)('Identifier')},function(a,b,c){const d=c(0);a.exports=d('IdentifierList')},function(a){a.exports={Type:'Integer',generate(a){return{value:` ${a}:[0-9]+`,toString(){return this.value+' _'}}}}},function(a){a.exports=(a)=>({Type:'Optional',generate:(b,c,d)=>({value:` ${b}:(${a.generate(b+'_',c,d).value})?`,toString(){return this.value+' _'}})})},function(a){a.exports=(...a)=>({type:'Or',generate(b,c,d){return{value:` ${b}:(${a.map((a,e)=>a.generate(b+e,c,d).value).join(' / ')})`,toString(){return this.value+' _'}}}})},function(a){a.exports={Type:'RequiredWhitespace',generate(){return{toString:()=>'_'}}}},function(a,b,c){a.exports=c(0)('Statement')},function(a,b,c){a.exports=c(0)('StatementList')}])});