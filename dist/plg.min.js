(function(a,b){'object'==typeof exports&&'object'==typeof module?module.exports=b(require('pegjs'),function(){try{return require('fs')}catch(a){}}()):'function'==typeof define&&define.amd?define(['pegjs','fs'],b):'object'==typeof exports?exports.plg=b(require('pegjs'),function(){try{return require('fs')}catch(a){}}()):a.plg=b(a.pegjs,a.fs)})(this,function(a,b){return function(a){function b(d){if(c[d])return c[d].exports;var e=c[d]={i:d,l:!1,exports:{}};return a[d].call(e.exports,e,e.exports,b),e.l=!0,e.exports}var c={};return b.m=a,b.c=c,b.d=function(a,c,d){b.o(a,c)||Object.defineProperty(a,c,{configurable:!1,enumerable:!0,get:d})},b.n=function(a){var c=a&&a.__esModule?function(){return a['default']}:function(){return a};return b.d(c,'a',c),c},b.o=function(a,b){return Object.prototype.hasOwnProperty.call(a,b)},b.p='',b(b.s=15)}([function(a){a.exports=(a)=>({Type:'Rule',Name:a,generate(a){return{value:` ${a}:${this.Name}`,toString(){return this.value+' _'}}}})},function(a){a.exports=(...a)=>({type:'Or',generate(b,c,d){return{value:` ${b}:(${a.map((a,e)=>a.generate(b+e,c,d).value).join(' / ')})`,toString(){return this.value+' _'}}}})},function(a,b,c){a.exports=c(0)('Expression')},function(a){a.exports=(a)=>({Type:'Optional',generate:(b,c,d)=>({value:` ${b}:(${a.generate(b+'_',c,d).value})?`,toString(){return this.value+' _'}})})},function(a,b,c){a.exports=c(0)('ExpressionList')},function(a,b,c){a.exports=c(0)('Identifier')},function(a,b,c){a.exports=c(0)('StatementList')},function(a){a.exports=(a,b)=>{let c,d;for(const e of a)if([c,d]=e.evaluate(b),'return'===c)return[c,d];return[null,d]}},function(a){a.exports=(a,b=!1)=>({Type:'Literal',Value:a,Insensitive:b,generate(a){return{value:` ${a}:"${this.Value.replace(/"/g,'\\"')}"${this.Insensitive?'i':''}`,toString(){return this.value+' _'}}}})},function(a){a.exports={Type:'Next',generate(a,b){return{value:` ${a}:${b}`,toString(){return this.value+' _'}}}}},function(a,b,c){const d=c(0);a.exports=d('IdentifierList')},function(a,b,c){a.exports=c(0)('Statement')},function(a){a.exports=(a,b)=>{let c;for(const d of a)c=d.evaluate(b);return c}},function(a){a.exports={type:'Current',generate(a,b,c){return{value:` ${a}:${c}`,toString(){return this.value+' _'}}}}},function(a,b,c){const d=c(29);a.exports=class{constructor(a,b){this.grammar=a;try{c(30).writeFileSync('./grammar.pegjs',this.grammar,'utf8')}catch(a){}this.parser=d.generate(a),this.parser.handler=b}evaluate(a,b){return this.evaluateStatements(this.parser.parse(a),b)}evaluateStatements(a,b){let c,d;for(let e of a)if([c,d]=e.evaluate(b),'return'===c)return d;return d}async evaluateAsync(a,b){return this.evaluateStatementsAsync(this.parser.parse(a),b)}async evaluateStatementsAsync(a,b){let c,d;for(let e of a)if([c,d]=await e.evaluate(b),'return'===c)return d;return d}}},function(a,b,c){a.exports={addArrayExpressions:c(16),addArrowFunctionExpressions:c(17),addAssignmentExpression:c(18),addBooleanExpressions:c(19),addGroupingExpressions:c(20),addIfStatements:c(21),addMathExpressions:c(22),addMemberExpressions:c(23),addObjectExpressions:c(24),addTransformExpressions:c(25),Current:c(13),evaluateExpressions:c(12),evaluateExpressionsAsync:c(26),evaluateStatements:c(7),evaluateStatementsAsync:c(27),Expression:c(2),ExpressionList:c(4),Grammar:c(28),Identifier:c(5),IdentifierList:c(10),Integer:c(32),Interpreter:c(14),Literal:c(8),Next:c(9),Optional:c(3),Or:c(1),RequiredWhitespace:c(33),Rule:c(0),Statement:c(11),StatementList:c(6)}},function(a,b,c){const d=c(0),e=c(1),f=c(2);a.exports=(a)=>a.addList({Alias:'ArrayItemList',Rule:'ArrayItem',Terminator:','}).addCustom({Alias:'ArrayItem',Tokens:{value:e(d('ArraySpread'),d('ArrayRange'),d('ArrayItemExpression'))},Handler:({value:a},b)=>a.evaluate(b)}).addCustom({Alias:'ArraySpread',Tokens:{spreadOperator:'...',value:f},Handler:({value:a},b)=>({[Symbol.for('type')]:'spread',value:a.evaluate(b)})}).addCustom({Alias:'ArrayRange',Tokens:{start:f,spread:'...',end:f},Handler:({start:a,end:b},c)=>{a=a.evaluate(c),b=b.evaluate(c);let d=[];for(let e=a;a<b?e<=b:e>=b;a<b?e++:e--)d.push(e);return{[Symbol.for('type')]:'spread',value:d}}}).addCustom({Alias:'ArrayItemExpression',Tokens:{expression:f},Handler:({expression:a},b)=>({[Symbol.for('type')]:'item',value:a.evaluate(b)})}).addExpression({Alias:'ArrayExpression',Tokens:{openBrace:'[',expressionList:d('ArrayItemList'),closeBrace:']'},Handler:({expressionList:a},b)=>{let c=[];for(const d of a){const a=d.evaluate(b);'spread'===a[Symbol.for('type')]?c.push(...a.value):c.push(a.value)}return c}})},function(a,b,c){const d=c(0),e=c(1),f=c(5),h=c(10),i=c(3),j=c(6),k=c(2),g=c(7);a.exports=(a)=>a.addCustom({Alias:'ArrowFunctionCodeBlock',Tokens:{open_brace:'{',statements:j,close_brace:'}'},Handler:({statements:a},b)=>{return g(a,b)}}).addBinaryExpression({Alias:'ArrowFunctionExpression',Left:e(f,d('FunctionParameters')),Operator:'=>',Right:e(d('ArrowFunctionCodeBlock'),k),Handler:({left:a,right:b},c)=>{let d=a?'Identifier'===a.Type?[a]:a:[];d.map((a)=>a.value);let e=Object.getOwnPropertyNames(c).filter((a)=>!d.includes(a));return(...d)=>{let f=Object.assign({},c);for(let b=0;b<a.length;b++)f[a[b].value]=d[b];const[g,h]=b.evaluate(f);return e.forEach((a)=>{c[a]=f[a]}),h}}}).addCustom({Alias:'FunctionParameters',Tokens:{open:'(',parameters:i(h),close:')'},Handler:({parameters:a})=>{return a}})},function(a,b,c){const d=c(0);a.exports=(a)=>a.addBinaryExpression({Alias:'AssignmentExpression',Left:d('MemberExpression'),Operator:'=',Handler:({left:a,right:b},c)=>{let d,e=c;const{root:f,path:g}=a.props,h=[f,...(g||[])],j=new Error(`Invalid member path: ${a.text} at ${JSON.stringify(a.location)}`);for(let f=0;f<h.length-2;f++)if(d='Identifier'===h[f].type?h[f].value:h[f].evaluate(c),e.hasOwnProperty(d))e=e[d];else throw j;const i=h[h.length-1];if(d='Identifier'===i.type?i.value:i.evaluate(c),e.hasOwnProperty(d))return e[d]=b.evaluate(c);throw j}})},function(a){a.exports=(a)=>a.addUnaryExpression({Alias:'Not',Operator:'!',Handler:({expression:a},b)=>!a.evaluate(b)}).addExpression({Alias:'True',Tokens:{value:'true'},Handler:()=>!0}).addExpression({Alias:'False',Tokens:{value:'false'},Handler:()=>!1}).reserve('true','false')},function(a,b,c){const d=c(4);a.exports=(a)=>a.addExpression({Alias:'Grouping',Tokens:{open:'(',expressions:d,close:')'},Handler:({expressions:a},b)=>evaluateExpressions(a,b)})},function(a,b,c){const d=c(0),e=c(2),f=c(6),h=c(1),g=c(7),i=c(3),j=c(11);a.exports=(a)=>a.addStatement({Alias:'IfStatement',Tokens:{ifKeyword:'if',open:'(',conditional:e,close:')',block:h(j,d('IfCodeBlock')),elseBlock:i(d('ElseIfBlock'))},Handler:({conditional:a,block:b,elseBlock:c},d)=>{return a.evaluate(d)?b.evaluate(d):c.evaluate(d)}}).addCustom({Alias:'IfCodeBlock',Tokens:{open:'{',statements:f,close:'}'},Handler:({statements:a},b)=>g(a,b)}).addCustom({Alias:'ElseIfBlock',Tokens:{elseKeyword:'else',block:h(d('IfStatement'),d('IfCodeBlock'))},Handler:({block:a},b)=>a.evaluate(b)}).reserve('if','else')},function(a,b,c){const d=c(4),e=c(12);a.exports=(a)=>a.addBinaryExpression({Alias:'Addition',Operator:'+',Handler:({left:a,right:b},c)=>a.evaluate(c)+b.evaluate(c)}).addBinaryExpression({Alias:'Subtraction',Operator:'-',Handler:({left:a,right:b},c)=>a.evaluate(c)-b.evaluate(c)}).addUnaryExpression({Alias:'Negative',Operator:'-',Handler:({expression:a},b)=>-a.evaluate(b)}).addBinaryExpression({Alias:'Multiplication',Operator:'*',Handler:({left:a,right:b})=>a.evaluate(context)*b.evaluate(context)}).addBinaryExpression({Alias:'Division',Operator:'/',Handler:({left:a,right:b})=>a.evaluate(context)/b.evaluate(context)}).addBinaryExpression({Alias:'Exponent',Operator:'**',Handler:({left:a,right:b})=>a.evaluate(context)**b.evaluate(context)})},function(a,b,c){const d=c(5),e=c(3),f=c(0),h=c(1),i=c(4);a.exports=(a)=>a.addExpression({Alias:'MemberExpression',Tokens:{root:d,path:e(f('MemberExpressionPathItemList'))},Handler:({root:a,path:b},c)=>{let d=c[a.value];b=b||[];for(const e of b){if('undefined'==typeof d)throw new Error('Invalid Access at '+JSON.stringify(e.location));d=d[e.evaluate(c)]}return d}}).addList({Alias:'MemberExpressionPathItemList',Rule:'MemberExpressionPathItem'}).addCustom({Alias:'MemberExpressionPathItem',Tokens:{pathItem:h(f('IdentifierProperty'),f('DynamicProperty'))},Handler:({pathItem:a},b)=>a.evaluate(b)}).addCustom({Alias:'IdentifierProperty',Tokens:{dot:'.',pathItem:d},Handler:({pathItem:a})=>a.value}).addCustom({Alias:'DynamicProperty',Tokens:{openBracket:'[',expressions:i,closeBracket:']'},Handler:({expressions:a},b)=>{let c;for(const d of a)c=d.evaluate(b);return c}})},function(a,b,c){const d=c(0),e=c(1),f=c(8),g=c(2),h=c(5);a.exports=(a)=>a.addList({Alias:'ObjectExpressionItemList',Rule:'ObjectExpressionItem',Terminator:','}).addCustom({Alias:'ObjectExpressionItem',Tokens:{value:e(d('ObjectSpread'),d('KeyValuePair'))},Handler:({value:a},b)=>a.evaluate(b)}).addCustom({Alias:'ObjectSpread',Tokens:{spreadOperator:'...',value:g},Handler:({value:a},b)=>({[Symbol.for('type')]:'spread',value:a.evaluate(b)})}).addCustom({Alias:'KeyValuePair',Tokens:{key:h,seperator:':',expression:g},Handler:({key:a,expression:b},c)=>({[Symbol.for('type')]:'keypair',key:a,value:b.evaluate(c)})}).addExpression({Alias:'ObjectExpression',Tokens:{openBrace:'{',expressionList:d('ObjectExpressionItemList'),closeBrace:'}'},Handler:({expressionList:a},b)=>{let c={};for(const d of a){const a=d.evaluate(b);'spread'===a[Symbol.for('type')]?Object.assign(c,a.value):c[a.key.value]=a.value}return c}})},function(a,b,c){const d=c(0),e=c(9),f=c(3),h=c(4);a.exports=(a)=>a.addExpression({Alias:'Transform',Tokens:{left:e,operator:'|',right:d('MemberExpression'),parameters:f(d('TransformParameters'))},Handler:({left:a,right:b,parameters:c},d)=>b.evaluate(d)(a.evaluate(d),...(c?c.evaluate(d):[]))}).addCustom({Alias:'TransformParameters',Tokens:{open:'(',expressions:f(h),close:')'},Handler:({expressions:a},b)=>{const c=[];for(const d of a)c.push(d.evaluate(b));return c}})},function(a){a.exports=async(a,b)=>{let c=null;for(const d of a)c=await d.evaluate(b);return c}},function(a){a.exports=async(a,b)=>{let c,d;for(const e of a)if([c,d]=await e.evaluate(b),'return'===c)return[c,d];return[null,d]}},function(a,b,c){const d=c(0),e=c(9),f=c(13),g=c(8),h=c(14);a.exports=class{constructor(){this.counts={E:-1,S:-1,C:-1,L:-1},this.handler={E:{},S:{},C:{}},this.keywords=[],this.terminator=';',this.grammar=c(31)}setTerminator(a){return this.terminator=a,this}addBinaryExpression(a){return this.addRule({Alias:a.Alias,Tokens:{left:a.Left||e,operator:g(a.Operator),right:a.Right||f},Type:'E',Handler:a.Handler})}addUnaryExpression(a){return this.addRule({Alias:a.Alias,Tokens:'right'===a.Type?{expression:a.Expression||e,operator:g(a.Operator)}:{operator:g(a.Operator),expression:a.Expression||f},Type:'E',Handler:a.Handler})}addExpression(a){const{Alias:b,Tokens:c,Handler:d}=a;return this.addRule({Alias:b,Tokens:c,Type:'E',Handler:d})}addStatement(a){const{Alias:b,Tokens:c,Handler:d}=a;return this.addRule({Alias:b,Tokens:c,Type:'S',Handler:d})}addCustom(a){const{Alias:b,Tokens:c,Handler:d}=a;return this.addRule({Alias:b,Tokens:c,Type:'C',Handler:d})}addRule(a){const{Alias:b,Tokens:c,Type:d,Handler:e}=a;console.log('adding',b),this.counts[d]+=1;const f=`${d}${this.counts[d]}`;this.handler[d][f]=e;const g=`${d}${this.counts[d]+1}`;return this.grammar+=`
${b?`${b} = ${f}
`:``}${f} = ${this.spliceTokens(c,g,f)} {
  return {
    alias: "${b}",
    nodeType: "${d}",
    type: "${f}",
    evaluate,
    props: { ${Object.getOwnPropertyNames(c).join(', ')} },
    text: text(),
    location: location()
  };
} ${'S'===d||'E'===d?`/ ${g}`:``}
`,this}addList(a){this.counts.L+=1;const b=`L${this.counts.L}`,c=a.Terminator?`_ "${a.Terminator.replace(/"/g,'\\"')}" `:``;return this.grammar+=`
${b} = ${a.Rule}
${a.Alias} = first:${b} last:(${c} _ ${b})* ${a.Terminator?c+'?':''} {
  return [first, ...last.map(x => x[${a.Terminator?3:1}])];
}
`,this}spliceTokens(a,b,c){let d='',e=Object.entries(a);for(let f=0;f<e.length;f++){let[a,h]=e[f];d+=(h.constructor===String?g(h):h).generate(a,b,c).toString()}return d}reserve(...a){return this.keywords.push(...a),this}generate(){return this.grammar+=`

E${this.counts.E+1} = ExpressionExit
S${this.counts.S+1} = StatementExit

${this.keywords.length?`Keyword = (${this.keywords.map((a)=>`"${a.replace(/"/g,'\\"')}"`).join(' / ')})`:'Keyword = "1"'} 
Terminator = "${this.terminator}"
`,new h(this.grammar,this.handler)}}},function(b){b.exports=a},function(a){if('undefined'==typeof b){var c=new Error('Cannot find module "fs"');throw c.code='MODULE_NOT_FOUND',c}a.exports=b},function(a){a.exports='{\r\n  const { handler } = this;\r\n\r\n  function evaluate(context) {\r\n    return handler[this.nodeType][this.type](this.props, context);\r\n  }\r\n  handler.S.SExpressionStatement = function SExpressionStatement({ expressions }, context) {\r\n    let value;\r\n    for(const expression of expressions) {\r\n      value = expression.evaluate(context);\r\n    }\r\n    return [null, value];\r\n  };\r\n  handler.E.EReturnValue = function EReturnValue({ value }) { return value; }\r\n}\r\n\r\nProgram = _ statements:StatementList _ {\r\n  return statements;\r\n}\r\n\r\nStatementList = first:Statement last:(_ Statement)* {\r\n  return [first, ...last.map(x => x[1])];\r\n}\r\nExpressionList = first:Expression last:(_ \',\' _ Expression)* {\r\n  return [first, ...last.map(x => x[3])];\r\n}\r\nIdentifier = !Keyword [a-zA-Z$_][a-zA-Z$_0-9]* {\r\n  return {\r\n    nodeType: \'I\',\r\n    type: \'Identifier\',\r\n    value: text(),\r\n    text: text(),\r\n    location: location()\r\n  };\r\n}\r\nIdentifierList = first:Identifier last:(_ "," _ Identifier) {\r\n  return [first, ...last.map(x => x[3])];\r\n}\r\n\r\nStatement = S0\r\nExpression = E0\r\n\r\nExpressionExit = Float\r\n\r\nFloat = [0-9]+ "." [0-9]+ {\r\n  return {\r\n    nodeType: \'E\',\r\n    type: \'EReturnValue\',\r\n    evaluate,\r\n    props: {\r\n      value: parseFloat(text()),\r\n    },\r\n    text: text(),\r\n    location: location()\r\n  };\r\n} / Integer\r\n\r\nInteger = [0-9]+ {\r\n  return {\r\n    nodeType: \'E\',\r\n    type: \'EReturnValue\',\r\n    evaluate,\r\n    props: {\r\n      value: parseInt(text(), 10),\r\n    },\r\n    text: text(),\r\n    location: location()\r\n  };\r\n} / Null\r\n\r\nNull = "null" {\r\n  return {\r\n    nodeType: \'E\',\r\n    type: \'EReturnValue\',\r\n    evaluate,\r\n    props: {\r\n      value: null,\r\n    },\r\n    text: text(),\r\n    location: location()\r\n  };\r\n}\r\n\r\nStatementExit = ExpressionStatement\r\n\r\nExpressionStatement = expressions:ExpressionList _ Terminator? {\r\n  return {\r\n    alias: \'ExpressionStatement\',\r\n    nodeType: "S",\r\n    type: \'SExpressionStatement\',\r\n    evaluate,\r\n    props: { expressions },\r\n    text: text(),\r\n    location: location()\r\n  };\r\n}\r\n\r\n_ = [\\t\\r\\n ]*\r\n__ = [\\t\\r\\n ]+'},function(a){a.exports={Type:'Integer',generate(a){return{value:` ${a}:[0-9]+`,toString(){return this.value+' _'}}}}},function(a){a.exports={Type:'RequiredWhitespace',generate(){return{toString:()=>'_'}}}}])});